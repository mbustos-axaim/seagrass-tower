//
//  GPS2RTC
//  Randy John
//  May 25, 2013
//
//  This code will set the RTC from a GPS receiver.  After 10 seconds it will set the compensation.
//  Subsequently, it will resychronize the RTC on each second while connected.  It will not change the compensation again.
//  Compensation is saved by the RTC battery.  If you wish to recalculate the compensation you need to call "RTC_TCR = 0"
//  or remove the RTC battery.  The battery is not required.
//
//  To use this software it is only necessary to create an instance of the class and call 'begin' specifying the serial port,
//  the baud rate and the pin that is connected to the 1pps pin:
//      #include <TinyGPS.h>
//      #include "gps2rtc.h"
//      const int gps_1pps_pin = 9;
//      GPS2RTC gps2rtc;
//      gps2rtc.begin(&Serial3, 9600, gps_1pps_pin);
//
//  Notes.
//  o Runs on the Teensy 3.0 (Freescale K20).
//  o Requires a HardwareSerial with its RX pin connected to the GPS receiver TX pin (RX is unused).
//  o Requires the modified HardwareSerial.h and serial1.c (and 2 and 3) that supports 'set_rx_isr'.
//  o Requires an input pin connected to the GPS receiver 1PPS pin.  This software will set the pin to be an input with a pull-down.
//  o Requires the TinyGPS library.
//
//  The time is set in terms of seconds past midnight UT which you can fetch by calling "rtc_get()".
//  Oh yes, the latitude and longitude is saved.
//

#include <hardwareserial.h>
#include <TinyGPS.h>

//#define DUMP_RAW_NMEA

enum GPS_TO_RTC_STATE
{
	looking_for_serial_data = 0,
	waiting_for_1pps = 1,
	set_rtc_compensation = 2,
	done = 3
};

const int sample_time_secs = 10;              // We will check the RTC after 10 seconds to see how far off it is from the GPS receiver.

class GPS2RTC
{
public:
	void begin(HardwareSerial* a_gps_serial, int a_baud_rate, int a_gps_1pps_pin)
        // This began life as a constructor but it couldn't handle the HardwareSerial.
	{
		gps_serial = a_gps_serial;
		gps_1pps_pin = a_gps_1pps_pin;

		gps_serial->begin(a_baud_rate);				// Initialize the serial port (both pins) and set the baud rate.
		pinMode_input_with_pulldown(gps_1pps_pin);	        // The 1PPS signal from the GPS receiver is connected to this pin.
									// We need the pull-down because the receiver is sometimes disconnected.
		gps_serial->set_rx_isr(&handle_gps_receiver_data);
                state = looking_for_serial_data;
                delay(1000);                                            // Wait one second for the RTC to come up to speed.
		attachInterrupt(gps_1pps_pin, gps_1pps_isr, RISING);
	};

	static void pinMode_input_with_pulldown(uint8_t pin)
        // Sets pin 'pin' as an input with a pulldown resistor.
	{
		volatile uint32_t *config;

		*portModeRegister(pin) = 0;
		config = portConfigRegister(pin);
		*config = PORT_PCR_MUX(1) | PORT_PCR_PE; // Pull-down.
	}

	static void handle_gps_record()
	// Handle one record sent from the GPS receiver.
	{
		unsigned long l_gps_time;
		unsigned long l_new_gps_time;
		long l_latitude;		// In decimal degrees * 100000.
		long l_longitude;		// In decimal degrees * 100000.
		unsigned long l_fix_age;	// Milliseconds since the last fix.

		// Try to get the time.
		gps.get_datetime(NULL, &l_gps_time, &l_fix_age);

		// If it's available and recent, convert it to seconds since midnight and save it.
		if (state == looking_for_serial_data && l_gps_time != 0 && l_fix_age != TinyGPS::GPS_INVALID_AGE && l_fix_age <= 2000)
		{
			l_gps_time = l_gps_time / 100;				    // Convert HHMMSS00 to HHMMSS.
			l_new_gps_time = l_gps_time % 100;			    // Get SS.
			l_gps_time = l_gps_time / 100;				    // Convert HHMMSS to HHMM.
			l_new_gps_time = l_new_gps_time + (l_gps_time % 100) * 60;  // Get MM and convert to seconds.
			l_gps_time = l_gps_time / 100;				    // Convert HHMM to HH.
			gps_time = l_new_gps_time + (l_gps_time % 100) * 3600;	    // Get HH and convert to seconds.
			state = waiting_for_1pps;				    // This enables (or reenables) 'gps_1pps_isr'.
		}

		// Try to get the position.
		gps.get_position(&l_latitude, &l_longitude, &l_fix_age);

		// If it's available and recent, save it.
		if (l_fix_age != TinyGPS::GPS_INVALID_AGE && l_fix_age <= 2000)
		{
			latitude = l_latitude;
			longitude = l_longitude;
		}
	}

	static void handle_gps_receiver_data(char a_char)
	// Handle one character of data from the GPS receiver. 
	{
		#ifdef DUMP_RAW_NMEA
			Serial.print(a_char);
		#endif

                if (gps.encode(a_char))
			handle_gps_record();
	}

	static void gps_1pps_isr()
	// Handle an interrupt generated by the rising edge of the 1PPS signal from the GPS receiver.
	{
		int l_new_time;
		static int l_count;
                int l_tpr;
                int l_tpr_saved;

                switch (state)
                {
                  case waiting_for_1pps:
                    l_new_time = gps_time + 1;          // This is the start of a new second.

                    if (l_new_time >= seconds_per_day)
                      l_new_time = 0;

                    rtc_set(l_new_time);		// This also sets the Time Prescale Register (RTC_TPR) to 0.  This syncs the RTC seconds with the 1PPS.

                    if (RTC_TCR == 0)
                    {
                      l_count = 0;
                      state = set_rtc_compensation;
                    }
                    else
                      state = looking_for_serial_data;  // The compensation has already been set.

                    break;
                  case set_rtc_compensation:
                    l_count++;
                    if (l_count == sample_time_secs)
                    {
                      RTC_TCR = ((sample_time_secs - 1) << 8) | ((-RTC_TPR) & 0xff);		// Compensation of -RTC_TPR ticks every 10th second.
                      state = looking_for_serial_data;
                    }

                    break;
                }
	}

	static enum GPS_TO_RTC_STATE state;             // See enum GPS_TO_RTC_STATE.

	static HardwareSerial* gps_serial;              // The serial port that is connected to the GPS receiver.

	static int gps_1pps_pin;                        // The pin number that is connected to the GPS receiver's 1PPS pin.

	static TinyGPS gps;                             // Routines to decode GPS NMEA messages.

	static int gps_time;				// Seconds since midnight decoded from the GPS receiver stream.

	static unsigned long latitude;			// In decimal degrees * 100000.

	static unsigned long longitude;			// In decimal degrees * 100000.

	static const int seconds_per_day = 86400;	// Number of seconds in a day.
};

